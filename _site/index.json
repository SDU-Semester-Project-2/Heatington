{
  "Documentation/CODING-STYLE.html": {
    "href": "Documentation/CODING-STYLE.html",
    "title": "SP2 Coding Guidelines | Heatington",
    "keywords": "SP2 Coding Guidelines Semester Project: Development of Software Systems, (F24) - Group 16 March 2024 Run code formatter dotnet format Coding style This document defines the coding style used throughout the project. The coding style is essentialy the one outlined by Microsoft for C# projects It is a slightly modified version of the following document. We use Allman style braces, where each brace begins on a new line. A single line statement block can go without braces but the block must be properly indented on its own line and must not be nested in other statement blocks that use braces (See rule 18 for more details). One exception is that a using statement is permitted to be nested within another using statement by starting on the following line at the same indentation level, even if the nested using contains a controlled block. We use four spaces of indentation (no tabs). We use _camelCase for internal and private fields and use readonly where possible. Prefix internal and private instance fields with _, static fields with s_ and thread static fields with t_ . When used on static fields, readonly should come after static (e.g. static readonly not readonly static). Public fields should be used sparingly and should use PascalCasing with no prefix when used. We avoid this. unless absolutely necessary. We always specify the visibility, even if it’s the default (e.g. private string foo not string foo). Visibility should be the first modifier (e.g. public abstract not abstract public). Namespace imports should be specified at the top of the file, outside of namespace declarations, and should be sorted alphabetically, with the exception of System.* namespaces, which are to be placed on top of all others. Avoid more than one empty line at any time. For example, do not have two blank lines between members of a type. Avoid spurious free spaces. For example avoid if (someVar = 0). . . =, where the dots mark the spurious free spaces. If a file happens to differ in style from these guidelines (e.g. private members are named m_member rather than member), the existing style in that file takes precedence. We only use var when the type is explicitly named on the right-hand side, typically due to either new or an explicit cast, e.g. var stream = new FileStream(...) not var stream = OpenStandardInput(). We use language keywords instead of BCL types (e.g. int, string, float instead of Int32, String, Single, etc) for both type references as well as method calls (e.g. int.Parse instead of Int32.Parse). We use PascalCasing to name all our constant local variables and fields. The only exception is for interop code where the constant value should exactly match the name and value of the code you are calling via interop. We use PascalCasing for all method names, including local functions. We use nameof(...) instead of \"...\" whenever possible and relevant. Fields should be specified at the top within type declarations. When including non-ASCII characters in the source code use Unicode escape sequences instead of literal characters. Literal non-ASCII characters occasionally get garbled by a tool or editor. When using labels (for goto), indent the label one less than the current indentation. 1 When using a single-statement if, we follow these conventions Never use single-line form (for example: if (source = null) throw new ArgumentNullException(‘‘source’’); Using braces is always accepted, and required if any block of an if=/=else if=/.../=else compound statement uses braces or if a single statement body spans multiple lines. Braces may be omitted only if the body of every block associated with an if=/=else if=/.../=else.compound statement is placed on a single line. Make allinternal and private types static or sealed unless derivation from them is required. As with any implementation detail, they can be changed if/when derivation is required in the future."
  },
  "Documentation/Heatington.Tests/Controllers/FileController.Tests.html": {
    "href": "Documentation/Heatington.Tests/Controllers/FileController.Tests.html",
    "title": "FileControllerTests Class | Heatington",
    "keywords": "FileControllerTests Class Namespace: Heatington.Tests.Controllers Description Unit tests for the FileController class. Constructor FileControllerTests() Creates a temporary test folder for testing purposes. Members ReadFileFromPath_ReadFile_ReadsCorrectContent() Unit test to verify that reading a file from a specified path reads the correct content. WriteFileFromPath_WriteFile_WritesCorrectContent() Unit test to verify that writing to a file from a specified path writes the correct content. WriteFileFromPath_WriteEmptyStringToFile_CreatesFile() Unit test to verify that writing an empty string to a file creates the file. WriteToFileFromPath_WriteToTheSameFileTwice_CreatesTwo() Unit test to verify that writing to the same file twice creates two files with the same name. ReadFileFromPath_ReadNotExistingFile_FileNotFound(string wrongFileName) Unit test to verify that reading from a path to a file that does not exist throws a FileNotFoundException. IDisposable Implementation Dispose() Clears the temporary test directory after all tests have been run."
  },
  "Documentation/Heatington/AssetManager/AssetManagerDescription.html": {
    "href": "Documentation/Heatington/AssetManager/AssetManagerDescription.html",
    "title": "Asset Manager | Heatington",
    "keywords": "Asset Manager The AM is a repository for static system information and is responsible for making this information available for other modules. The AM can hold its data in local files. Through the AM, other modules can retrieve heating grid information such as name and a graphical representation of the grid. The AM provides all configuration data for the production units such as name, possible operation points and a graphical representation of the units itself. An operation point defines how a device can be operated. Parameters are produced heat, produced / consumed electricity, production costs, consumption of primary energy, produced CO2 emissions. There is typically a minimum and a maximum operation point but, in this case, we assume that there is a maximum operation point for each unit which can be regulated to zero, meaning the device is switched off."
  },
  "Documentation/Heatington/Controllers/Enums/OperationStatus.html": {
    "href": "Documentation/Heatington/Controllers/Enums/OperationStatus.html",
    "title": "OperationStatus Enum | Heatington",
    "keywords": "OperationStatus Enum Namespace: Heatington.Controllers.Enums Description Enumeration representing the status of an operation. Members SUCCESS = 0: Indicates a successful operation. LOADING = 1: Indicates that the operation is in progress or loading. FAILURE = 2: Indicates a failed operation. \u0003"
  },
  "Documentation/Heatington/Controllers/FileController.html": {
    "href": "Documentation/Heatington/Controllers/FileController.html",
    "title": "FileController Class | Heatington",
    "keywords": "FileController Class Namespace: Heatington.Controllers Example string pathToFile = Utilities.GeneratePathToFileInAssetsDirectory(\"testFile.json\"); IReadWriteController fileController = new FileController(pathToFile); await fileController.WriteData(\"1\"); string? data = await fileController.ReadData(); Description Class for performing read/write actions on local files. Constructor FileController(string pathToFile) Class constructor. Gets a path to the file to control. Parameters pathToFile (string): Path to the location of a file. Follows the pattern file.json. Members TryFileOperationRunner<T>(Func<Task<T>> funcToTry) Helper method performing try-catch clauses in file-oriented manner. Parameters funcToTry (Func<Task >): Function to run inside of try-catch block. Type Parameters T: Return type of a function. Returns Return the outcome of the run function. If the function returns void, the lambda function should return 0. ReadFileFromPath() Function for reading the contents of a local file. Reads from the path passed during object initialization. Returns Content of the file as a string. Exceptions FileNotFoundException: If the file does not exist or the path is not correct, the exception is thrown. WriteToFileFromPath(string content) Function for writing string data into a local file from a path. Parameters content (string): Content to be written to a file as a string. ReadData<T>() Function for reading the data of a local file. Reads from the path passed during object initialization. Returns Data of the file as a string. WriteData<T>(T content) Function for writing data into a local file. Parameters content (T): Content to be written to a file as a string."
  },
  "Documentation/Heatington/Controllers/Interfaces/IReadWriteController.html": {
    "href": "Documentation/Heatington/Controllers/Interfaces/IReadWriteController.html",
    "title": "IReadWriteController Interface | Heatington",
    "keywords": "IReadWriteController Interface Namespace: Heatington.Controllers.Interfaces Description Generic Interface for all controllers performing I/O operations. Members Task<T?> ReadData<T>() Function for reading data out of a model. Returns Task to wait for Data. Task<OperationStatus> WriteData<T>(T content) Function for Writing data into the model. Parameters content: Content to write into the model, generic type. Returns Task to wait for status of the operation."
  },
  "Documentation/Heatington/Controllers/JsonController.html": {
    "href": "Documentation/Heatington/Controllers/JsonController.html",
    "title": "| Heatington",
    "keywords": ""
  },
  "Documentation/Heatington/Helpers/Utilities.html": {
    "href": "Documentation/Heatington/Helpers/Utilities.html",
    "title": "Utilities Class | Heatington",
    "keywords": "Utilities Class Namespace: Heatington.Helpers Description Utility class providing various helper methods. Members DisplayException(string message) Displays an exception message in red color in the console. Parameters message (string): The exception message to display. ConvertObject<T>(object? obj) Converts an object to the specified type T. Parameters obj (object): The object to convert. Returns The converted object of type T. GetAbsolutePathToAssetsDirectory() Gets the absolute path to the assets directory of the project. Returns The absolute path to the assets directory. GeneratePathToFileInAssetsDirectory(string fileName) Generates the path to a file in the assets directory based on the provided file name. Parameters fileName (string): The name of the file. Returns The full path to the file in the assets directory."
  },
  "Heatington/Controllers/CsvDataSource.html": {
    "href": "Heatington/Controllers/CsvDataSource.html",
    "title": "CsvDataSource Class | Heatington",
    "keywords": "CsvDataSource Class Overview The CsvDataSource class provides a concrete implementation of the IDataSource interface specific to data in CSV format, allowing for the reading of such data within the Heatington application. Methods Task<List<DataPoint>?> GetDataAsync(string filePath) The GetDataAsync method is a function for asynchronously fetching data from a CSV file located at a provided file path. The method initiates by asynchronously reading the file’s entire content into a string (rawData). The rawData is then deserialized by the CsvController utility class into a CsvData object – a controller specifically designed to handle and manipulate data in CSV format. Following the successful deserialization of the rawData, the CsvData object is converted into a List of DataPoint objects. Each DataPoint object encapsulates heat demand and electricity price data. Should the method fail to retrieve data from the file or if no data exists at the provided file path, then the method will return null. Upon the occurrence of an exception, the exception's message is displayed using the Utilities.DisplayException(e.Message) method and the exception is then re-thrown. void SaveData(List<DataPoint> data, string filePath) The SaveData method remains unimplemented and consequently triggers a NotImplementedException when called. It is projected that in the future, the method will save a List of DataPoint objects into a CSV file located at a specified file path. The List<DataPoint> data parameter represents the data points to be stored. The string filePath parameter provides the location of where the CSV file will be created or rewritten. The utilization of this method remains dependent upon the needs of the Heatington project. Remarks While the CsvDataSource class is intended to offer a concrete manner for handling CSV data in the application, it's worth to mention that its ability to write data is not implemented. Depending on future development decisions, this feature could potentially remain so. The future of object creation and modification may also leverage design patterns such as the Factory or Builder."
  },
  "Heatington/Controllers/Interfaces/IDataSource.html": {
    "href": "Heatington/Controllers/Interfaces/IDataSource.html",
    "title": "IDataSource Interface | Heatington",
    "keywords": "IDataSource Interface Overview The IDataSource interface serves as a protocol for managing data sources in the Heatington application. It stipulates the provision of methods to perform read and write operations on data. Methods Task<List<DataPoint>?> GetDataAsync(string filePath) The GetDataAsync method signifies an asynchronous operation for retrieving data from a specified data source. The input string filePath represents the path to the file containing the pertinent data. The method is expected to return a List<DataPoint> object, which contains the data of interest - specifically the heat demand and electricity price details. In cases where the data retrieval is unsuccessful or if there is no data present at the given file location, the method may return null. void SaveData(List<DataPoint> data, string filePath) The SaveData method is purposed towards storing DataPoint objects into a CSV file located at a specific file path. The List<DataPoint> data argument contains the data points that are set to be saved. The string filePath is an argument that provides the location at which the CSV file will be written to or overwritten. Considering that its return type is void, all complications that arise during the data-saving process should be conveyed via exceptions. This method is currently not implemented Implementations Any classes that function as Csv data sources within the Heatington application should implement this interface. This allows for consistency in the management of data across varying data sources and enables smoother transitions between different data sources. Examples of such classes could include CsvDataSource, XmlDataSource, and the like."
  },
  "Heatington/Models/DataPoint.html": {
    "href": "Heatington/Models/DataPoint.html",
    "title": "DataPoint Class | Heatington",
    "keywords": "DataPoint Class Introduction The DataPoint class in the Heatington application represents a single piece of data. Each instance of this class indicates the amount of heat used and the cost of electricity at a particular time. Structure DataPoint(string startTime, string endTime, string heatDemand, string electricityPrice) To create a new data point, we have a constructor that accepts four string parameters. startTime and endTime: These represent the start and end of a time frame. They must follow the \"M/d/yy H:mm\" pattern. To keep things standardized, we use DateTime.ParseExact and CultureInfo.InvariantCulture, which convert the strings into DateTime objects. heatDemand and electricityPrice: These values tell us how much heat was used and how much the electricity cost at that time. They are converted into double data types using double.Parse and CultureInfo.InvariantCulture. Properties StartTime This DateTime property marks the start of a data point's time frame. EndTime This DateTime property marks the end of a time frame for the data point. HeatDemand This double property shows the amount of heat used in the given time frame. ElectricityPrice This double reflects the cost of electricity during that time period. Future Considerations Adding a factory method to this class would allow us to manage specific object creation scenarios better, like parameter validation or offering more ways to create a DataPoint. Note We are not sure about the formatting of the HeatDemand and ElectricityPrice. Because of the different cultures, we might need to consider different decimal separators. We will need to test this in the future."
  },
  "Heatington/Optimizer/Optimizer.html": {
    "href": "Heatington/Optimizer/Optimizer.html",
    "title": "Documentation for optimizer | Heatington",
    "keywords": "Documentation for optimizer Optimizer module for the first scenario Properties _dataPoints -> will hold the hourly information loaded from the csv from the sdm _productionUnits -> hold the production units loaded Results -> public get, will hold the computed results Public methods LoadData() -> Loads data from the SDM to the OPT which are needed to compute the optimization OptimizeScenario1() -> Once the data is loaded, it will optimize the activation of heat boilers and make the results accessible CalculateNetProductionCost() -> Once the optimizer was run, this method will calculate the Net production costs for heat only boilers LogResults() -> Will display the computed results LogDataPoints() -> Will display the dataPoints if they are loaded from the SDM LogProductionUnits() -> Will display the loaded production units which will be used for the optimization Private methods SetOperationPoint() -> will be called to set the operation point on each boiler CalculateHeatUnitsRequired() -> is the main part of the optimizer as it organises the data and sets the appropriate computed values GetDataPoints() -> Loads data from the SDM GetProductionUnits() -> Loads production units (eventually from AM) How the logic works Once the optimizer starts optimizing: each dataPoint loaded needs to be optimized production Units need to be stored sorted by efficiency Determines how many boilers need to be activated Based on that number the correct boilers are selected Once the boilers are selected their operation point is set All the information is added to an object ResultHolder which is added to a local list After the foreach loop is completed the results are added to the public property Now the netProductionCosts can be computed First iteration of the OPT module Everything under here is left as history, nothing applies anymore. Scenario 1 The optimizer class has three private fields. _productionUnits holds the production units objects _energyDataEntries hold the data eventually provided by the SDM, which reads them from the CSV _resultEntries currently holds how many boilers need to be activated for any given time period Optimize scenario 1 OptimzeScenario1does what it sounds like. It optimizes the first scenario, there are only heat boilers, no electricity has to be taken into consideration After getting the production units and the time series data which holds how many Mwh are to be produced it orders the production units by their production cost For each \"hour\" it calls CalculateHeatingUnitsRequired which calculates how many heating units have to be activated to satisfy the heating demand BEWARE CalculateHeatingUnitsRequired returns how many heating units need to be activated. This number references the index of the productionUnit list, meaning that 0 means only the production unit with index 0. 2 would mean all the production units with index 0, 1, 2 Net Production cost Since heat only boilers have no further income or expenses it useful to know what the cost of production is. Once the OptimzeScenario1() has run NetProductionCost() can be executed. Currently it just calculates it and displays it on screen. Once RDM is implemented it will correctly format the data and make it available to the RDM. General expedients The class is not completed, this is only the initial implementation Most classes with which it works with, are going to be changed calling for major refactoring It tried to adhere to the SOLID principle as much as possible, refactoring should work ok"
  },
  "Heatington/SourceDataManager/SourceDataManager.html": {
    "href": "Heatington/SourceDataManager/SourceDataManager.html",
    "title": "SourceDataManager Class | Heatington",
    "keywords": "SourceDataManager Class Brief Overview The SourceDataManager class is the static repository for the Heatington application's core data management. It gets data from and saves data to a specific data source, which is an form of IDataSource interface. Important Bits _dataSource: This is a private copy of the the IDataSource interface. It has all the methods needed to work with a specific data source. _filePath: This is a private copy of the path to the file where the data operations happen. TimeSeriesData: This public List<DataPoint> works like a holding area for the data. Each item represents a data point at a specific time. Constructor SourceDataManager(IDataSource dataSource, string filePath) Constructing a new SourceDataManager needs an IDataSource instance and a file path string. This gives it the flexibility to work with any type of data source and file location. We use constructor injection to make sure that SourceDataManager is not tightly coupled to any specific data source. Core Methods ConvertApiToCsv(List<DataPoint> dataFromApi): This takes a list of DataPoint items and saves them using the SaveData method from IDataSource. This method is for future use when we implement the API-driven iteration. FetchTimeSeriesData(): This method fetches the data from the _dataSource using the GetData method and stores it in the TimeSeriesData property. LogTimeSeriesData(): This method logs the data in TimeSeriesData. Each log message contains the index, formatted start and end times, heat demand, and electricity price for each data point. This method will be removed once we move to the GUI-driven iteration. Quick Note The SourceDataManager implementation simplifies testing because IDataSource can be easily mocked. It also adds flexibility, as different implementations of IDataSource can be used without major code changes. An Example Of How To Use It using Heatington.Data; namespace Heatington { internal static class Program { public static async Task Main(string[] args) // async Task -> if we want to implement async operation // especially for IO { // Define the file path const string filePath = \"../Assets/winter_period.csv\"; // Create a new CsvDataSource IDataSource dataSource = new CsvDataSource(); SourceDataManager.SourceDataManager sdm = new(dataSource, filePath); // Fetch data from dataSource await sdm.FetchTimeSeriesDataAsync().ConfigureAwait(true); // Log the loaded data to the console sdm.LogTimeSeriesData(); Console.WriteLine(\"Data loaded successfully.\"); } } }"
  },
  "README.html": {
    "href": "README.html",
    "title": "Heatington | Heatington",
    "keywords": "Heatington Open Coding Style Guidelines What are we developing Heat production optimization for a district heating utility Secure heat availability for all buildings in the district heating network Produce heat for the lowest costs Utilize the electricity market for the highest profit or lowest costs Five Components Asset Manager (AM) Source Data Manager (SDM) Result Data Mangaer (RDM) Optimizer (OPT) Data Visualization (DV) Two Scenarios Single heating area, one gas boiler, one oil boiler Single heating area, one gas boiler, one oil boiler, one gas motor, one electric boiler Two Periods Winter period Summer Period Example of heating net Component Diagram Class Diagram"
  },
  "api/Heatington.AssetManager.AssetManager.html": {
    "href": "api/Heatington.AssetManager.AssetManager.html",
    "title": "Class AssetManager | Heatington",
    "keywords": "Class AssetManager Namespace Heatington.AssetManager Assembly Heatington.dll public class AssetManager Inheritance object AssetManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Examples AssetManager AM = new AssetManager(); await AM.LoadAssets(); Constructors AssetManager() public AssetManager() Properties HeatingGridInformation public HeatingGrid? HeatingGridInformation { get; } Property Value HeatingGrid ProductionUnits public Dictionary<ProductionUnitsEnum, ProductionUnit>? ProductionUnits { get; } Property Value Dictionary<ProductionUnitsEnum, ProductionUnit> Methods LoadAssets() public Task LoadAssets() Returns Task ReadHeatingUnits() public Dictionary<ProductionUnitsEnum, ProductionUnit> ReadHeatingUnits() Returns Dictionary<ProductionUnitsEnum, ProductionUnit> ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. WriteHeatingUnit(ProductionUnit) public void WriteHeatingUnit(ProductionUnit editedHeatingUnit) Parameters editedHeatingUnit ProductionUnit WriteHeatingUnit(ProductionUnitsEnum, ProductionUnit) public void WriteHeatingUnit(ProductionUnitsEnum productionUnitKey, ProductionUnit heatingUnitNewbBody) Parameters productionUnitKey ProductionUnitsEnum heatingUnitNewbBody ProductionUnit WriteHeatingUnit(Guid, ProductionUnit) public void WriteHeatingUnit(Guid unitId, ProductionUnit heatingUnitNewbBody) Parameters unitId Guid heatingUnitNewbBody ProductionUnit"
  },
  "api/Heatington.AssetManager.HeatingGrid.html": {
    "href": "api/Heatington.AssetManager.HeatingGrid.html",
    "title": "Class HeatingGrid | Heatington",
    "keywords": "Class HeatingGrid Namespace Heatington.AssetManager Assembly Heatington.dll public class HeatingGrid Inheritance object HeatingGrid Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HeatingGrid(string, string) public HeatingGrid(string picturePath, string name) Parameters picturePath string name string Properties Id public Guid Id { get; set; } Property Value Guid Name public string Name { get; set; } Property Value string PicturePath public string PicturePath { get; set; } Property Value string"
  },
  "api/Heatington.AssetManager.ProductionUnit.html": {
    "href": "api/Heatington.AssetManager.ProductionUnit.html",
    "title": "Class ProductionUnit | Heatington",
    "keywords": "Class ProductionUnit Namespace Heatington.AssetManager Assembly Heatington.dll public class ProductionUnit : ICloneable Inheritance object ProductionUnit Implements ICloneable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ProductionUnit(string, string, double, double, double, double, double) public ProductionUnit(string name, string picturePath, double maxHeat, double productionCost, double maxElectricity, double gasConsumption, double co2Emission) Parameters name string picturePath string maxHeat double productionCost double maxElectricity double gasConsumption double co2Emission double Properties Co2Emission public double Co2Emission { get; } Property Value double GasConsumption public double GasConsumption { get; } Property Value double Id public Guid Id { get; } Property Value Guid MaxElectricity public double MaxElectricity { get; } Property Value double MaxHeat public double MaxHeat { get; } Property Value double Name public string Name { get; set; } Property Value string OperationPoint public double OperationPoint { get; set; } Property Value double PicturePath public string PicturePath { get; } Property Value string ProductionCost public double ProductionCost { get; } Property Value double Methods Clone() Creates a new object that is a copy of the current instance. public object Clone() Returns object A new object that is a copy of this instance. ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/Heatington.AssetManager.ProductionUnitsEnum.html": {
    "href": "api/Heatington.AssetManager.ProductionUnitsEnum.html",
    "title": "Enum ProductionUnitsEnum | Heatington",
    "keywords": "Enum ProductionUnitsEnum Namespace Heatington.AssetManager Assembly Heatington.dll public enum ProductionUnitsEnum Fields ElectricBoiler = 3 GasBoiler = 0 GasMotor = 2 OilBoiler = 1"
  },
  "api/Heatington.AssetManager.html": {
    "href": "api/Heatington.AssetManager.html",
    "title": "Namespace Heatington.AssetManager | Heatington",
    "keywords": "Namespace Heatington.AssetManager Classes AssetManager HeatingGrid ProductionUnit Enums ProductionUnitsEnum"
  },
  "api/Heatington.Controllers.CsvController.html": {
    "href": "api/Heatington.Controllers.CsvController.html",
    "title": "Class CsvController | Heatington",
    "keywords": "Class CsvController Namespace Heatington.Controllers Assembly Heatington.dll public class CsvController : IDataSource Inheritance object CsvController Implements IDataSource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetDataAsync(string) public Task<List<DataPoint>?> GetDataAsync(string filePath) Parameters filePath string Returns Task<List<DataPoint>> SaveData(List<DataPoint>, string) public void SaveData(List<DataPoint> data, string filePath) Parameters data List<DataPoint> filePath string"
  },
  "api/Heatington.Controllers.Enums.OperationStatus.html": {
    "href": "api/Heatington.Controllers.Enums.OperationStatus.html",
    "title": "Enum OperationStatus | Heatington",
    "keywords": "Enum OperationStatus Namespace Heatington.Controllers.Enums Assembly Heatington.dll Documentation in Documents/Heatington/Controllers/Enums/OperationStatus.md public enum OperationStatus Fields FAILURE = 2 LOADING = 1 SUCCESS = 0"
  },
  "api/Heatington.Controllers.Enums.html": {
    "href": "api/Heatington.Controllers.Enums.html",
    "title": "Namespace Heatington.Controllers.Enums | Heatington",
    "keywords": "Namespace Heatington.Controllers.Enums Enums OperationStatus Documentation in Documents/Heatington/Controllers/Enums/OperationStatus.md"
  },
  "api/Heatington.Controllers.FileController.html": {
    "href": "api/Heatington.Controllers.FileController.html",
    "title": "Class FileController | Heatington",
    "keywords": "Class FileController Namespace Heatington.Controllers Assembly Heatington.dll Documentation in Documents/Heatington/Controllers/FileController.md public class FileController : IReadWriteController Inheritance object FileController Implements IReadWriteController Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors FileController(string) Documentation in Documents/Heatington/Controllers/FileController.md public FileController(string pathToFile) Parameters pathToFile string Methods ReadData<T>() public Task<T> ReadData<T>() Returns Task<T> Type Parameters T ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. WriteData<T>(T) public Task<OperationStatus> WriteData<T>(T content) Parameters content T Returns Task<OperationStatus> Type Parameters T"
  },
  "api/Heatington.Controllers.Interfaces.IReadWriteController.html": {
    "href": "api/Heatington.Controllers.Interfaces.IReadWriteController.html",
    "title": "Interface IReadWriteController | Heatington",
    "keywords": "Interface IReadWriteController Namespace Heatington.Controllers.Interfaces Assembly Heatington.dll Documentation in Documents/Heatington/Controllers/Interfaces/IReadWriteController.md public interface IReadWriteController Methods ReadData<T>() Task<T> ReadData<T>() Returns Task<T> Type Parameters T ToString() string? ToString() Returns string WriteData<T>(T) Task<OperationStatus> WriteData<T>(T content) Parameters content T Returns Task<OperationStatus> Type Parameters T"
  },
  "api/Heatington.Controllers.Interfaces.ISerializeDeserialize.html": {
    "href": "api/Heatington.Controllers.Interfaces.ISerializeDeserialize.html",
    "title": "Interface ISerializeDeserialize | Heatington",
    "keywords": "Interface ISerializeDeserialize Namespace Heatington.Controllers.Interfaces Assembly Heatington.dll public interface ISerializeDeserialize Methods Deserialize<T>(string) public static abstract T? Deserialize<T>(string file) Parameters file string Returns T Type Parameters T Serialize<T>(T) public static abstract string? Serialize<T>(T obj) Parameters obj T Returns string Type Parameters T"
  },
  "api/Heatington.Controllers.Interfaces.html": {
    "href": "api/Heatington.Controllers.Interfaces.html",
    "title": "Namespace Heatington.Controllers.Interfaces | Heatington",
    "keywords": "Namespace Heatington.Controllers.Interfaces Interfaces IReadWriteController Documentation in Documents/Heatington/Controllers/Interfaces/IReadWriteController.md ISerializeDeserialize"
  },
  "api/Heatington.Controllers.JsonController.html": {
    "href": "api/Heatington.Controllers.JsonController.html",
    "title": "Class JsonController | Heatington",
    "keywords": "Class JsonController Namespace Heatington.Controllers Assembly Heatington.dll public class JsonController : ISerializeDeserialize, IReadWriteController Inheritance object JsonController Implements ISerializeDeserialize IReadWriteController Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors JsonController(string) public JsonController(string filePath) Parameters filePath string Methods Deserialize<T>(string) public static T Deserialize<T>(string file) Parameters file string Returns T Type Parameters T ReadData<T>() public Task<T> ReadData<T>() Returns Task<T> Type Parameters T Serialize<T>(T) public static string Serialize<T>(T obj) Parameters obj T Returns string Type Parameters T ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. WriteData<T>(T) public Task<OperationStatus> WriteData<T>(T content) Parameters content T Returns Task<OperationStatus> Type Parameters T"
  },
  "api/Heatington.Controllers.ProductionUnitJsonConverter.html": {
    "href": "api/Heatington.Controllers.ProductionUnitJsonConverter.html",
    "title": "Class ProductionUnitJsonConverter | Heatington",
    "keywords": "Class ProductionUnitJsonConverter Namespace Heatington.Controllers Assembly Heatington.dll public class ProductionUnitJsonConverter : JsonConverter<ProductionUnit> Inheritance object JsonConverter JsonConverter<ProductionUnit> ProductionUnitJsonConverter Inherited Members JsonConverter<ProductionUnit>.CanConvert(Type) JsonConverter<ProductionUnit>.ReadAsPropertyName(ref Utf8JsonReader, Type, JsonSerializerOptions) JsonConverter<ProductionUnit>.WriteAsPropertyName(Utf8JsonWriter, ProductionUnit, JsonSerializerOptions) JsonConverter<ProductionUnit>.HandleNull JsonConverter<ProductionUnit>.Type object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Reads and converts the JSON to type ProductionUnit. public override ProductionUnit Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The reader. typeToConvert Type The type to convert. options JsonSerializerOptions An object that specifies serialization options to use. Returns ProductionUnit The converted value. Write(Utf8JsonWriter, ProductionUnit, JsonSerializerOptions) Writes a specified value as JSON. public override void Write(Utf8JsonWriter writer, ProductionUnit productionUnit, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The writer to write to. productionUnit ProductionUnit options JsonSerializerOptions An object that specifies serialization options to use."
  },
  "api/Heatington.Controllers.Serializers.CsvConstructorAttribute.html": {
    "href": "api/Heatington.Controllers.Serializers.CsvConstructorAttribute.html",
    "title": "Class CsvConstructorAttribute | Heatington",
    "keywords": "Class CsvConstructorAttribute Namespace Heatington.Controllers.Serializers Assembly Heatington.dll [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)] public sealed class CsvConstructorAttribute : Attribute Inheritance object Attribute CsvConstructorAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Heatington.Controllers.Serializers.html": {
    "href": "api/Heatington.Controllers.Serializers.html",
    "title": "Namespace Heatington.Controllers.Serializers | Heatington",
    "keywords": "Namespace Heatington.Controllers.Serializers Classes CsvConstructorAttribute"
  },
  "api/Heatington.Controllers.html": {
    "href": "api/Heatington.Controllers.html",
    "title": "Namespace Heatington.Controllers | Heatington",
    "keywords": "Namespace Heatington.Controllers Classes CsvController FileController Documentation in Documents/Heatington/Controllers/FileController.md JsonController ProductionUnitJsonConverter"
  },
  "api/Heatington.Data.IDataSource.html": {
    "href": "api/Heatington.Data.IDataSource.html",
    "title": "Interface IDataSource | Heatington",
    "keywords": "Interface IDataSource Namespace Heatington.Data Assembly Heatington.dll public interface IDataSource Methods GetDataAsync(string) Task<List<DataPoint>?> GetDataAsync(string filePath) Parameters filePath string Returns Task<List<DataPoint>> SaveData(List<DataPoint>, string) void SaveData(List<DataPoint> data, string filePath) Parameters data List<DataPoint> filePath string"
  },
  "api/Heatington.Data.html": {
    "href": "api/Heatington.Data.html",
    "title": "Namespace Heatington.Data | Heatington",
    "keywords": "Namespace Heatington.Data Interfaces IDataSource"
  },
  "api/Heatington.Helpers.Utilities.html": {
    "href": "api/Heatington.Helpers.Utilities.html",
    "title": "Class Utilities | Heatington",
    "keywords": "Class Utilities Namespace Heatington.Helpers Assembly Heatington.dll public static class Utilities Inheritance object Utilities Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Methods ConvertObject<T>(object?) public static T ConvertObject<T>(object? obj) Parameters obj object Returns T Type Parameters T DisplayException(string) public static void DisplayException(string message) Parameters message string GeneratePathToFileInAssetsDirectory(string) public static string GeneratePathToFileInAssetsDirectory(string fileName) Parameters fileName string Returns string GetAbsolutePathToAssetsDirectory() public static string GetAbsolutePathToAssetsDirectory() Returns string ToString() public static string ToString() Returns string"
  },
  "api/Heatington.Helpers.html": {
    "href": "api/Heatington.Helpers.html",
    "title": "Namespace Heatington.Helpers | Heatington",
    "keywords": "Namespace Heatington.Helpers Classes Utilities"
  },
  "api/Heatington.Models.DataPoint.html": {
    "href": "api/Heatington.Models.DataPoint.html",
    "title": "Class DataPoint | Heatington",
    "keywords": "Class DataPoint Namespace Heatington.Models Assembly Heatington.dll public class DataPoint Inheritance object DataPoint Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DataPoint(string, string, string, string) public DataPoint(string startTime, string endTime, string heatDemand, string electricityPrice) Parameters startTime string endTime string heatDemand string electricityPrice string Properties ElectricityPrice public double ElectricityPrice { get; } Property Value double EndTime public DateTime EndTime { get; } Property Value DateTime HeatDemand public double HeatDemand { get; } Property Value double StartTime public DateTime StartTime { get; } Property Value DateTime"
  },
  "api/Heatington.Models.ResultHolder.html": {
    "href": "api/Heatington.Models.ResultHolder.html",
    "title": "Class ResultHolder | Heatington",
    "keywords": "Class ResultHolder Namespace Heatington.Models Assembly Heatington.dll public class ResultHolder Inheritance object ResultHolder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ResultHolder(DateTime, DateTime, double, double, double, List<ProductionUnit>) public ResultHolder(DateTime startTime, DateTime endTime, double heatDemand, double electricityPrice, double netProductionCost, List<ProductionUnit> boilers) Parameters startTime DateTime endTime DateTime heatDemand double electricityPrice double netProductionCost double boilers List<ProductionUnit> Properties Boilers public List<ProductionUnit> Boilers { get; set; } Property Value List<ProductionUnit> ElectricityPrice public double ElectricityPrice { get; } Property Value double EndTime public DateTime EndTime { get; } Property Value DateTime HeatDemand public double HeatDemand { get; } Property Value double NetProductionCost public double NetProductionCost { get; set; } Property Value double StartTime public DateTime StartTime { get; } Property Value DateTime Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/Heatington.Models.html": {
    "href": "api/Heatington.Models.html",
    "title": "Namespace Heatington.Models | Heatington",
    "keywords": "Namespace Heatington.Models Classes DataPoint ResultHolder"
  },
  "api/Heatington.Optimizer.Opt.html": {
    "href": "api/Heatington.Optimizer.Opt.html",
    "title": "Class Opt | Heatington",
    "keywords": "Class Opt Namespace Heatington.Optimizer Assembly Heatington.dll public class Opt Inheritance object Opt Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Results public List<ResultHolder>? Results { get; } Property Value List<ResultHolder> Methods CalculateNetProductionCost() public void CalculateNetProductionCost() LoadData() public void LoadData() LogDataPoints() public void LogDataPoints() LogProductionUnits() public void LogProductionUnits() LogResults() public void LogResults() OptimizeScenario1() public void OptimizeScenario1()"
  },
  "api/Heatington.Optimizer.html": {
    "href": "api/Heatington.Optimizer.html",
    "title": "Namespace Heatington.Optimizer | Heatington",
    "keywords": "Namespace Heatington.Optimizer Classes Opt"
  },
  "api/Heatington.SourceDataManager.SourceDataManager.html": {
    "href": "api/Heatington.SourceDataManager.SourceDataManager.html",
    "title": "Class SourceDataManager | Heatington",
    "keywords": "Class SourceDataManager Namespace Heatington.SourceDataManager Assembly Heatington.dll public class SourceDataManager Inheritance object SourceDataManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SourceDataManager(IDataSource, string) public SourceDataManager(IDataSource dataSource, string filePath) Parameters dataSource IDataSource filePath string Properties TimeSeriesData public List<DataPoint>? TimeSeriesData { get; set; } Property Value List<DataPoint> Methods ConvertApiToCsv(List<DataPoint>) public void ConvertApiToCsv(List<DataPoint> dataFromApi) Parameters dataFromApi List<DataPoint> FetchTimeSeriesDataAsync() public Task FetchTimeSeriesDataAsync() Returns Task LogTimeSeriesData() public void LogTimeSeriesData()"
  },
  "api/Heatington.SourceDataManager.html": {
    "href": "api/Heatington.SourceDataManager.html",
    "title": "Namespace Heatington.SourceDataManager | Heatington",
    "keywords": "Namespace Heatington.SourceDataManager Classes SourceDataManager"
  },
  "api/Heatington.Tests.Controllers.FileControllerTests.html": {
    "href": "api/Heatington.Tests.Controllers.FileControllerTests.html",
    "title": "Class FileControllerTests | Heatington",
    "keywords": "Class FileControllerTests Namespace Heatington.Tests.Controllers Assembly Heatington.Tests.dll Documentation in Documents/Heatington.Tests/Controllers/FileController.Tests.md public class FileControllerTests : IDisposable Inheritance object FileControllerTests Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FileControllerTests() public FileControllerTests() Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() ReadFileFromPath_ReadFile_ReadsCorrectContent() [Fact] public void ReadFileFromPath_ReadFile_ReadsCorrectContent() ReadFileFromPath_ReadNotExistingFile_FileNotFound(string) [Theory] [InlineData(new object[] { \"aaa1\" })] [InlineData(new object[] { \"test.cvs\" })] [InlineData(new object[] { \"csv.ctest\" })] [InlineData(new object[] { \"./adsfsaf.json\" })] [InlineData(new object[] { \"../../asets\" })] [InlineData(new object[] { \"c:\\\\78fe9lk\" })] [InlineData(new object[] { \"/root12\" })] [InlineData(new object[] { \"./Jsons\" })] [InlineData(new object[] { \"./123\" })] public void ReadFileFromPath_ReadNotExistingFile_FileNotFound(string wrongFileName) Parameters wrongFileName string WriteFileFromPath_WriteEmptyStringToFile_CreatesFile() [Fact] public void WriteFileFromPath_WriteEmptyStringToFile_CreatesFile() WriteFileFromPath_WriteFile_WritesCorrectContent() [Fact] public void WriteFileFromPath_WriteFile_WritesCorrectContent() WriteToFileFromPath_WriteToTheSameFileTwice_CreatesTwo() [Fact] public void WriteToFileFromPath_WriteToTheSameFileTwice_CreatesTwo()"
  },
  "api/Heatington.Tests.Controllers.html": {
    "href": "api/Heatington.Tests.Controllers.html",
    "title": "Namespace Heatington.Tests.Controllers | Heatington",
    "keywords": "Namespace Heatington.Tests.Controllers Classes FileControllerTests Documentation in Documents/Heatington.Tests/Controllers/FileController.Tests.md"
  },
  "api/Heatington.Tests.UnitTest1.html": {
    "href": "api/Heatington.Tests.UnitTest1.html",
    "title": "Class UnitTest1 | Heatington",
    "keywords": "Class UnitTest1 Namespace Heatington.Tests Assembly Heatington.Tests.dll public class UnitTest1 Inheritance object UnitTest1 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Test1() [Fact] public void Test1()"
  },
  "api/Heatington.Tests.html": {
    "href": "api/Heatington.Tests.html",
    "title": "Namespace Heatington.Tests | Heatington",
    "keywords": "Namespace Heatington.Tests Classes UnitTest1"
  },
  "docs/Optimizer.html": {
    "href": "docs/Optimizer.html",
    "title": "Documentation for optimizer | Heatington",
    "keywords": "Documentation for optimizer Optimizer module for the first scenario Properties _dataPoints -> will hold the hourly information loaded from the csv from the sdm _productionUnits -> hold the production units loaded Results -> public get, will hold the computed results Public methods LoadData() -> Loads data from the SDM to the OPT which are needed to compute the optimization OptimizeScenario1() -> Once the data is loaded, it will optimize the activation of heat boilers and make the results accessible CalculateNetProductionCost() -> Once the optimizer was run, this method will calculate the Net production costs for heat only boilers LogResults() -> Will display the computed results LogDataPoints() -> Will display the dataPoints if they are loaded from the SDM LogProductionUnits() -> Will display the loaded production units which will be used for the optimization Private methods SetOperationPoint() -> will be called to set the operation point on each boiler CalculateHeatUnitsRequired() -> is the main part of the optimizer as it organises the data and sets the appropriate computed values GetDataPoints() -> Loads data from the SDM GetProductionUnits() -> Loads production units (eventually from AM) How the logic works Once the optimizer starts optimizing: each dataPoint loaded needs to be optimized production Units need to be stored sorted by efficiency Determines how many boilers need to be activated Based on that number the correct boilers are selected Once the boilers are selected their operation point is set All the information is added to an object ResultHolder which is added to a local list After the foreach loop is completed the results are added to the public property Now the netProductionCosts can be computed First iteration of the OPT module Everything under here is left as history, nothing applies anymore. Scenario 1 The optimizer class has three private fields. _productionUnits holds the production units objects _energyDataEntries hold the data eventually provided by the SDM, which reads them from the CSV _resultEntries currently holds how many boilers need to be activated for any given time period Optimize scenario 1 OptimzeScenario1does what it sounds like. It optimizes the first scenario, there are only heat boilers, no electricity has to be taken into consideration After getting the production units and the time series data which holds how many Mwh are to be produced it orders the production units by their production cost For each \"hour\" it calls CalculateHeatingUnitsRequired which calculates how many heating units have to be activated to satisfy the heating demand BEWARE CalculateHeatingUnitsRequired returns how many heating units need to be activated. This number references the index of the productionUnit list, meaning that 0 means only the production unit with index 0. 2 would mean all the production units with index 0, 1, 2 Net Production cost Since heat only boilers have no further income or expenses it useful to know what the cost of production is. Once the OptimzeScenario1() has run NetProductionCost() can be executed. Currently it just calculates it and displays it on screen. Once RDM is implemented it will correctly format the data and make it available to the RDM. General expedients The class is not completed, this is only the initial implementation Most classes with which it works with, are going to be changed calling for major refactoring It tried to adhere to the SOLID principle as much as possible, refactoring should work ok"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | Heatington",
    "keywords": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | Heatington",
    "keywords": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | Heatington",
    "keywords": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}